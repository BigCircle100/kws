#include <httplib.h>
#include <signal.h>
#include <unistd.h>
#include <fstream>
#include <iostream>
#include <json.hpp>
#include <map>
#include <sstream>
#include <string>
#include "sound_classification_v2.cpp"

using json = nlohmann::json;

// 可以并发处理的最大请求数
int MAX_REQUEST_AMOUNT = 10;
std::atomic<int> current_requests(0);

// 用于处理程序中断的信号处理函数
void signal_handler(int signum) {
  std::cout << "程序被中断。" << std::endl;
  std::exit(signum);  // 退出程序
}

class PidFile {
 public:
  PidFile(const char* path) : path_(path) {
    std::ofstream pid_file(path_);
    if (!pid_file) {
      throw std::runtime_error("无法创建 PID 文件");
    }
    pid_file << getpid();  // 写入当前进程的 PID
  }

  ~PidFile() {
    unlink(path_);  // 删除 PID 文件
  }

  bool is_running() const {
    std::ifstream pid_file(path_);
    if (!pid_file) {
      return false;  // PID 文件不存在
    }

    pid_t pid;
    pid_file >> pid;  // 读取 PID

    // 检查进程是否存在
    if (kill(pid, 0) == 0) {
      return true;  // 进程仍在运行
    } else {
      return false;  // 进程不存在
    }
  }

 private:
  const char* path_;
};


// 全局变量
std::map<std::string, std::shared_ptr<SoundClassificationV2>> clients;


// 处理请求
void setup_routes(httplib::Server& server) {
  server.Post("/status", [](const httplib::Request&, httplib::Response& res) {
    auto name = clients.begin()->first;
    auto client = clients[name];
    json response = {{"messageType", "status"},
                     {"status", client->is_running() ? 1 : 0}};
    res.set_content(response.dump(), "application/json");
  });

  server.Post("/interrupt",
              [](const httplib::Request&, httplib::Response& res) {
                auto name = clients.begin()->first;
                auto client = clients[name];
                client->interrupt();
                json response = {{"code", 200}};
                res.set_content(response.dump(), "application/json");
              });

  server.Get("/health", [](const httplib::Request&, httplib::Response& res) {
    res.status = 200;
  });

  server.Post("/model", [](const httplib::Request&, httplib::Response& res) {
    auto name = clients.begin()->first;
    auto client = clients[name];
    json response = {{"name", name},
                     {"param",
                      {{"dev_id", client->get_dev_id()}
                      // todo 其他参数如果需要再说
                      }}};
    res.set_content(response.dump(), "application/json");
  });

  server.Post("/upload",
              [](const httplib::Request& req, httplib::Response& res) {
                json request_json = json::parse(req.body);
                std::string model_name = request_json["model"];

                // todo 请求体内容、接口待确定，需要包含语音数据内容、采样率、时长等，
                // 修改以下message作为推理参数
                std::string message = request_json["message"];

                auto client = clients.find(model_name);
                if (client == clients.end()) {
                  res.status = 404;
                  json response = {{"detail", "model " + model_name + " not Found"}};
                  res.set_content(response.dump(), "application/json");
                  return;
                }
                client->second->inference(message);
                json response = {{"code", 200}};
                res.set_content(response.dump(), "application/json");
              });
}

int main(int argc, char* argv[]) {
  std::string pid_file_path = "/tmp/kws_service.pid";
  PidFile pidfile(pid_file_path.c_str());
  if (pidfile.is_running()) {
    std::cerr << "语音唤醒服务已经在运行。" << std::endl;
    exit(1);
  }

  try {
    // 读取配置文件
    std::ifstream inputFile("../config.json");
    if (!inputFile.is_open()) {
      std::cerr << "未找到config文件" << std::endl;
    }

    json config;
    inputFile >> config;

    auto models_config = config["models"];
    int port = config["port"];

    for (const auto& model_config : models_config) {
      // json model_config;
      // for (const auto& key : model) {
      //   model_config[key.first.as<std::string>()] =
      //       key.second.as<std::string>();
      // }
      std::string name = model_config["name"];
      clients[name] = std::make_shared<SoundClassificationV2>(
          SoundClassificationV2(model_config["dev_id"].get<int>(),
                                model_config["bmodel_path"].get<std::string>(),
                                model_config["threshold"].get<float>()));
      // clients[name]->start();
    }

    httplib::Server server;
    server.
    setup_routes(server);
    std::cout << "TTS 服务启动，监听端口 " << port << "..." << std::endl;
    server.listen("0.0.0.0", port);
  } catch (const std::exception& e) {
    std::cerr << "错误: " << e.what() << std::endl;
  }

  return 0;
}
